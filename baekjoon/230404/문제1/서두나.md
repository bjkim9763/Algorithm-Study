## 문제 설명

- 새 집의 크기는 N×N의 격자판으로 나타낼 수 있고, 1×1크기의 정사각형 칸으로 나누어져 있다
- 대각선 이동 방향은 파이프 위치의 상, 좌 는 비어 있어야 한다.
- 집의 상태의 빈칸은 0, 벽은 1로 주어진다.
   - 빈칸만 이동 가능 
- 가장 처음에 파이프는 (1, 1)와 (1, 2)를 차지하고 있고, 방향은 가로이다. 파이프의 한쪽 끝을 (N, N)로 이동시키는 방법의 개수 구하는 문제

| 이전 방향 | 이동방향 |
| --- | --- |
| 가로 | 가로 |
| 가로 | 대각선 |
| 세로 | 세로 |
| 세로 | 대각선 |
| 대각선 | 가로 |
| 대각선 | 세로 |
| 대각선 | 대각선 |


``` python

import sys
from collections import deque

input = sys.stdin.readline
q = deque()


def dfs(r, c, d):   #파이프 도착 지점에 도착하는 파이프 개수
    global cnt  # 파이프 개수

    if r == n - 1 and c == n - 1: # 도착 지점
        cnt += 1
        return

    # d=0: 이전 파이프 가로 방향, d=2: 이전 파이프 대각선 방향
    if (d == 0 or d == 2) and 0 <= c + 1 < n and arr[r][c + 1] == 0:  # 다음 파이프가 가로 방향
        dfs(r, c + 1, 0)  # 가로 이동, 범위, 빈공간 확인

    # d=1: 이전 파이프 세로 방향
    if (d == 1 or d == 2) and 0 <= r + 1 < n and arr[r + 1][c] == 0:  # 다음 파이프가 세로 방향
        dfs(r + 1, c, 1)  # 세로 이동, 범위, 빈공간 확인

    if 0 <= c + 1 < n and 0 <= r + 1 < n and arr[r + 1][c] == 0 and arr[r][c + 1] == 0 and arr[r + 1][
        c + 1] == 0:  # 다음 파이프가 대각선 방향, 범위, 필요한 빈공간 확인
        dfs(r + 1, c + 1, 2)  # 대각선 이동


def main():
    global n, arr, cnt  # 집의 크기, 집의 상태, 파이프 개수

    cnt = 0
    n = int(input())
    arr = [list(map(int, input().split())) for _ in range(n)]

    if arr[n - 1][n - 1] != 1:  # 벽이 없는 공간에 파이프 이동
        dfs(0, 1, 0)

    print(cnt)


if __name__ == "__main__":
    main()


```

## 어려웠던 부분 & 해결 과정
파이썬은 bfs로 구현 시 시간 초과가 발생했으며, 같은 코드의 dfs 방식은 pypy3에서는 통과했다.
파이썬은 3차원 배열의 dp 방식만 시간 통과가 가능하다.

파이썬의 시간 복잡도를 생각해 푸는 방식을 공부할 것이다.
