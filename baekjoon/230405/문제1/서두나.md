## 문제 설명

- 트리의 1번 정점에는 W만큼의 물이 고여 있다. 1번 정점을 제외한 모든 정점에는 아직 물이 고여 있지 않은 상태이다.

- 물을 가지고 있으며, 자식 정점이 있다면 자식 정점 중 하나를 골라 물을 1 준다. 자식 정점이 여러 개라면 동일한 확률로 그 중 하나를 고른다.
- 만약 부모 정점이 자신에게 물을 흘려보냈다면 받아서 쌓아 둔다.
- 더 이상 물이 움직이지 않을 때, i번 정점에 쌓인 물의 양의 기댓값을 Pi라 하자. 이때, Pi가 0보다 큰 정점들에 대해서 Pi들의 평균 구하기

## 접근 방식
더 이상 물이 움직이지 않을때, 쌓인 물은 리프노드에 존재한다.
확률로 하나를 선택하는 방식인데, 만약 극단적으로 한 리프노드에만 물이 고여있다면, 정답은 틀린 것이다.
w/1의 평균값만 구하면 된다.
하지만 해당 리프노드에 물이 없을 수도 있다.
이러한 범위의 평균은 결국 모든 리프노드에 절반씩 들어간 양이다.

![image](https://user-images.githubusercontent.com/70767115/230152225-e3451423-69f4-49c5-989c-dbd99ba865cf.png)

현재 그래프에서 1에서 20 쌓인 물이 있다.
노드 2에 절반인 10이 물의 평균량이고, 노드 3에 10의 물이 쌓인다.
노드 3에서 노드 4, 5로 물이 이동한다면, 각각 평균 5 씩 물이 고일 것이다.

결과적으로 리프노드에 고인 물을 합하면 20이고 물의 양 평균값은 20/3 이다. 

이 문제에서는 리프노드의 수만 구해서 주어진 w 물이 고인 양을 나누면 나온다. 

``` python
import sys

input = sys.stdin.readline
sys.setrecursionlimit(5000000)


def dfs(cur, pre):  # 그래프 탐색으로 리프노드 개수 세기
    ans = 0  # 리프 노드 개수

    for next in graph[cur]:
        if pre != next:  # 이전 노드 중복 제외
            ans += dfs(next, cur)  # 리프 노드 개수 합

    return ans if ans > 0 else 1  # 리프 노드일때 1 반환


def main():
    global graph

    n, w = map(int, input().split())  # 정점 개수, 고인물의 양
    graph = [[] for _ in range(n + 1)]  # 그래프

    for _ in range(n - 1):  # 주어진 간선에 따라 그래프 연결
        u, v = map(int, input().split())
        graph[u].append(v)
        graph[v].append(u)

    print(w / dfs(1, 0))  # Pi들의 평균


if __name__ == "__main__":
    main()


```

## 어려웠던 부분 & 해결 과정
리프 노드를 더 빠르게 구하는 방법은 해당 그래프의 연결된 지점이 1개인지 확인하면 된다. 그래프가 일자로 연결되어도 결국 위, 아래로 연결돼 있어 최소 2개 이상이 나온다.