## 문제 설명

친구 관계 트리가 주어졌을 때, 모든 개인이 새로운 아이디어를 수용하기 위하여 필요한 최소 얼리 어답터의 수를 구하는 문제이다.

- 얼리 아답터가 아닌 사람들은 자신의 모든 친구들이 얼리 아답터일 때만 이 아이디어를 받아들인다

image.png


2, 3, 4번 노드가 표현하는 사람들이 얼리 아답터라면, 얼리 아답터가 아닌 사람들은 자신의 모든 친구가 얼리 아답터이기 때문에 새로운 아이디어를 받아들인다.

## 접근 방식

모든 친구가 새로운 아이디어를 받아들이기 위해서는 한 노드가 얼리 아답터가 아니면 모든 노드가 얼리 아답터야지 해당 노드가 새로운 아이디어를 받아들일 수 있다.

- 부모 노드가 얼리 아답터 o,자식 노드는 얼리 아답터 o or x
- 부모 노드가 얼리 아답터 x, 자식 노드는 얼리 아답터 o

부모 노드가 얼리 아답터이면 o 이면, 자식 노드는 접근해 있는데, 왜 o or x를 요구하는 것일까

위의 그래프 그림에서 1, 2, 4번 노드가 얼리 아답터라면 모든 사람이 새로운 아이디어를 받아들이는 경우가 가능하기 때문이다.

인접된 노드 두 개가 얼리 아답터라도 최소의 경우가 나올 수 있으므로, 얼리 아답터 o or x 의 두 가지 경우를 고려를 해야 한다.

주어진 N의 범위가 2 ≤ N ≤ 1,000,000 임으로,  완전 탐색을 진행하기엔 시간초과가 발생한다.

1,000,000*1,000,000*2 (시작하는 노드* 노드 전체 탐색 * 아답터 o or x)

그러므로 위의 조건으로 dp를 이용해 이전 노드에서 선택할 수 있는 최소의 얼리 아답터 수를 구해서 이전 노드를 연산을 안 하도록 해야한다.

## 문제 풀이

위의 조건을 이용해 dp 점화식을 세워 볼 것이다.

dp[0][n]: n 노드가 얼리 아답터 o일 때 나오는 최소 수

dp[1][n]: n 노드가 얼리 아답터 x일 때 나오는 최소 수

```python
dp[0][n] = min(dp[0][n-1], dp[1][n-1]) + 1
dp[1][n] = dp[0][n]
```

그래프 탐색을 재귀를 이용해 리프 노드부터 root 노드까지 되돌아갈 때 해당 점화식을 계산해줄 것이다. 마지막 root 노드에서 `dp[0][1], dp[1][0]` 에서 최솟값을 구하면 된다.

```python
import sys

sys.setrecursionlimit(1000000 * 2) # 노드가 한곳에 몰렸을때 나올수 있는 깊이 * 2 
input = sys.stdin.readline

# 재귀로 모든 노드를 탐색하는 코드
def solution(cur, pre): # cur: 현재 노드, pre: 이전 노드
    for next in graph[cur]:
        if pre != next: # 이전에 방문한 노드인지 확인 
            solution(next, cur)

            dp[0][cur] += min(dp[1][next], dp[0][next])  # 부모가 얼리 아답터 o, 자식 얼리 아답터 x or o
            dp[1][cur] += dp[0][next]  # 부모가 얼리 아답터 x, 얼리 아답터 o

    dp[0][cur] += 1 # 리프 노드를 카운트 해주기 위해 분리

def main():
    global graph, dp

    n = int(input()) # 노드 개수
    graph = [[] for _ in range(n + 1)] # 그래프
    dp = [[0 for _ in range(n + 1)] for _ in range(2)] # 노드일때 얼리 아답터 최소 수

    for _ in range(n - 1):
        u, v = map(int, input().split()) # 연결된 간선, 양뱡향
        graph[u].append(v)
        graph[v].append(u)

    solution(1, 0)
    print(min(dp[0][1], dp[1][1])) #모든 새로운 아이디어를 받아들이는 얼리 아답터 최소 수

if __name__ == "__main__":
    main()
```

## 어려웠던 부분 & 해결 과정

단방향 그래프를 적용해서 작성을 해 틀렸다. 양방향으로 적용 해야 원하는 답을 구할수 있다.

문제 예제는 단방향으로도 풀 수 있는 문제 이다. 하지만 단방향으로 답은 나오지만 모든 경우의 수를 구하지는 않았다.

단방향이면 시작하는 root 노드에 따라 답이 잘못 나올수 있다.

 
image.png



root 노드를 1이 아닌 2번부터 진행을 한다면 `1 → 2` 로만 연결이 돼 있다면, 2에서 1은 접근하지 못한다. 그리고 문제 예시는 `1 2` 로 데이터를 주지만 반대로 `2 1`이 주어지면 root 노드를 1부터 시작하면 누락이 발생한다.