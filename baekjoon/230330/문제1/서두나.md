## 문제 설명

세 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 세 용액을 찾는 문제

- 세 용액은 특성값의 오름차순으로 출력한다
- 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력
- 전체 용액의 수는 3 이상 5,000 이하
- 용액 특성값은 1,000,000,000 이상 1,000,000,000 이하

## 접근 방식

특성값이 0과 인접한 세계의 용액을 선택해야 한다.

용액 하나를 선택하고 나머지 두 개를 선택해서 더한 합이 최소인 것을 찾아야 한다.

처음에 용액 두개를 선택한 후 이분탐색으로 나머지 하나의 용액을 찾았지만, 이 과정에서 만약 전체 합이 0이 된다면 중복 처리 때문에 문제가 발생한다.

- 기존 용액 2개와 중복이 되면 안된다.
- 만약 중복인데 합이 0이면, 왼쪽, 오른쪽 둘 중에 어디가 최소인지 판단을 해줘야 한다.
- 만약 왼쪽, 오른쪽 둘 중에 하나가 기존 용액이 있는 위치이면 또 중복이 발생
- 가능한 위치까지 while 문으로 처리를 해준다는 가정에 최악의 경우 주어진 배열 범위를 넘을 수있다.
- 여기서 왼쪽, 오른쪽으로 찾을지도 고려를 해야 한다.

이러한 문제로 이분탐색 방식은 어렵다.

용액 하나를 선택해 나머지 용액을 투포인터로 진행하는 것이 좋다.

탐색하는 용액의 특성값을 정렬해서 0과 인접하는 수를 구하기 위해서는 음수와 양수를 합을 구하는 방법이 있다.

용액 특성이 양수만 또는 음수만 나올 수 있어서 위의 방식이 무조건 나오지는 않는다.

투포인터로 진행하면  양끝부터 조건에 따라 이동하면서 확인할 수 있기에 전부 탐색 O($n^2$)이 아닌 필요한 부분만 O(n)번 정도 탐색하면 필요한 경우의 수를 확인할 수 있다.

완전탐색으로 구현하려면 3중 포문으로도 가능할 것 같지만 모든 경우를 탐색하게 되어 시간초과가 발생할 것이다.

## 문제 풀이

첫번째 용액 특성 값을 선택해 그 위치 다음부터 마지막까지 투포인터로 탐색을 진행한다. left, right로 용액 두개를 선택하면서 전체 합을 구하고 그 전체 합이 0보다 크면 right 부분을 한칸 앞으로 이동해 더 작은 용액의 특성값 더해주는 형식으로 첫번째 용액을 선택할 때 나올 수 있는 가장 0에 인접한 특성값 합을 찾았다.

```python

import sys
from collections import deque

input = sys.stdin.readline
q = deque()

# 첫번째 용액 특성 값에 두번째, 세번째 용액의 합이 0에 인접한 합과 두번째, 세번째 용액의 위치를 반환해준다.
def solution(target):   # target: 첫번째 용액 위치
    left = target + 1   # 두번째 용액 위치, 첫번재 용액과 겹치지 않게, 중복 탐색 안하게
    right = n - 1   # 세번째 용액 위치
    minAns = 3000000001 # 용액 특성 최댓합 + 1
    b, c = -1, -1 # 반환할 두번째, 세번째 용액 특성값

    while left < right: # 두 용액의 위치가 같기전까지 탐색

        total = arr[left] + arr[right] + arr[target] # 세 용액의 합

        if abs(total) < minAns: # 0에 더 근접할때
            minAns = abs(total)
            b, c = right, left

        if total > 0:  # 특성 합이 양수이면
            right -= 1

        else:  # 나머지
            left += 1

    return (minAns, b, c)

def main():
    global arr, n
    answer = []
    n = int(input())  # 용액의 수
    arr = list(map(int, input().split()))  # 용액의 특성값
    arr.sort()  # 이분 탐색을 위한 정렬

    minAns = 3000000001  # 나올수 있는 최대 합+1

    # a, b, c = 0, 0, 0  # 정답 용액 위치 저장
    for a in range(n):  # 첫번째 용액 선택
        if minAns == 0:
            break
        v, b, c = solution(a)
        if minAns > v:  # 세개의 용액의 특성 값 합의 최소 값 구함
            minAns = v
            answer = [arr[a], arr[b], arr[c]]

    answer.sort()  # 오름차순 출력
    print(*answer)

if __name__ == "__main__":
    main()
```

## 시간 복잡도

투포인터는 O(n)* 첫번째 용액O(n)+오름차순 O(n)=O($n^2$)

## 공간 복잡도

공간이 하나씩 생김으로 O(1)

## 어려웠던 부분 & 해결 과정

두 용액의 합을 구하고 나머지 용액을 이분탐색으로 탐색할 때 중복 선택을 제거하는 코드를 생각하는데 오랜 시간이 걸렸다. 구현을 하기엔 고려해야하는게 많아, 투포인터로 다시 코드를 작성해야했다.