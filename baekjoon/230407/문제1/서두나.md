## 문제 설명
- 부 배열은 A[i], A[i+1], …, A[j-1], A[j] (단, 1 ≤ i ≤ j ≤ n)을 말한다
- 부 배열의 합은 A[i]+…+A[j]를 의미한다.
- A의 부 배열의 합에 B의 부 배열의 합을 더해서 T가 되는 모든 부 배열 쌍의 개수를 구한다.
- 가능한 경우가 한 가지도 없을 경우에는 0을 출력한다.


``` python
def main():
    answer = 0  # 부배열의 합 A, B의 합이 T가 되는 경우의 수

    t = int(input())  # 부배열의 합 T
    n = int(input())  # 배열 A의 크기
    a = list(map(int, input().split()))  # 배열 A
    m = int(input())  # 배열 B의 크기
    b = list(map(int, input().split()))  # 배열 B

    dic = {}  # 배열 A의 부배열의 합
    for i in range(n):  # 배열 A의 부배열 합을 구한다.
        for j in range(i + 1, n + 1):
            num = int(sum(a[i:j]))  # i ~ j 까지 연속된 수 합 
            if dic.get(num):  # 이미 저장된 합의 값 일때 +1 
                dic[num] += 1
            else:  # 새로운 저장되는 합의 값 일때 1
                dic[num] = 1

    for i in range(m):  # 배열 B의 부배열 합을 구한다.
        for j in range(i + 1, m + 1):
            num = t - int(sum(b[i:j]))  # T - i ~ j 까지 연속된 수 합
            if dic.get(num):  # 뺀 수가 A의 부배열 합에 존재하는지
                answer += dic[num]  # 존재하는 수 만큼 더해준다.

    print(answer)


if __name__ == "__main__":
    main()

```

## 어려웠던 부분 & 해결 과정

최악의 경우 모든 합의 범위가 -1,000,000,000 ~ 1,000,000,000 라고 생각해 배열을 만들어 제출을 해봤지만, 예상대로 메모리 초과였다.

결과가 중복도 있다고 생각하지만, 딕셔너리나 스택에 결괏값을 담는 방식이 통과하는 점이 궁금했다.

그래서 5개의 값이 있을 때 나오는 경우의 수를 작성해보니 원래 5! 이라고 생각했지만, 15개가 나왔다.

이유는 내가 부 배열의 합이라는 조건을 잊고 있었다.
연속되는 수의 합을 구하는 방식이라서 생각 이상으로 적은 수가 나온다.

크기가 n인 배열 합의 경우의 수는 n+(n-1)+(n-2) ...+1 임으로 1,000,000보다 작은 수다.

| 데이터 개수 | 메모리 사용량 |
| --- | --- |
| 1,000 | 약 4KB |
| 1,000,000 | 약 4MB |
| 10,000,000 | 약 40MB |

메모리 제한은 64MB 이므로 딕셔너리나 스택으로 문제를 해결할 수 있다.

참고하고 싶은 누적합으로 푸는 다른 방식
https://www.acmicpc.net/source/58920602