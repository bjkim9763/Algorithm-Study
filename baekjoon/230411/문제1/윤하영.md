## 어려웠던 부분 & 해결 과정

---

보통 DP는 시간제한을 극단적으로 줄이고 메모리를 넉넉하게 제시하는 편이었으므로 이 문제가 DP라고 생각하지 못했다.
같은날 풀이한 블로거 문제가 슬라이딩 윈도우 풀이였기 때문에 이 문제도 슬라이딩 윈도우로 접근하려다가 많은 시행착오를 겪었다.
LCS1과 LCS2를 접해보지 못해서 어려운 걸까 싶어서 1과 2를 검색해보았더니 DP 풀이였다.
한번 DP라는 사실을 인지하자 생각보다는 어렵지 않게 풀 수 있었던 것 같다.

## 문제 풀이

---

```cpp
// 백준 골드 1958 LCS 3
#include <iostream>
#include <string>
using namespace std;

int dp[101][101][101]; // dp[i][j][k]는 1번째 문자열의 i번째 문자, 2번째 문자열의 j번째 문자, 3번째 문자열의 k번째 문자 까지의 LCS를 저장하는 DP 변수.

int main(void) {
	string a, b, c;
	cin >> a >> b >> c;

	for(int i=1; i<=a.size(); i++)
	{
		for(int j=1; j<=b.size(); j++)
		{
			for(int k=1; k<=c.size(); k++)
			{
				// 1번째 문자열의 i번째 문자, 2번째 문자열의 j번째 문자, 3번째 문자열의 k번째 문자가 동일한지 확인한다
				if (a[i-1] == b[j-1] && a[i-1] == c[k-1] && b[j-1] == c[k-1])
				{
					// 동일하다면 LCS값을 +1 늘려준다.
					dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1;
				}
				else
				{
					// 하나라도 다르다면 현재까지 가지고 있던 LCS 값으로 초기화해준다.
					dp[i][j][k] = max(dp[i - 1][j][k], max(dp[i][j - 1][k], dp[i][j][k - 1]));
				}
			}
		}
	}

	// 출력
	cout << dp[a.size()][b.size()][c.size()]; 

	return 0;
}
```